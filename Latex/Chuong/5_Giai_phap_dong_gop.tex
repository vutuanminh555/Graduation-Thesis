\documentclass[../DoAn.tex]{subfiles}
\begin{document}

\section{Tổng quát thuật toán mã hóa tích chập và giải mã Viterbi}

Tính tổng quát hóa là một yêu cầu quan trọng của Endec Server, nhưng do thiết kế PL không thể thay đổi trong lúc hoạt động, việc xây dựng một kiến trúc phần cứng có thể xử lý nhiều cấu hình khác nhau trở thành một thách thức cần phải giải quyết.  
 
Đầu ra của mã hóa tích chập có thể biểu diễn bằng công thức:  
\[
\sum_{k=0}^n x^k \cdot y^k \quad \text{với} \quad n = K - 1
\]  

Trong đó:
\begin{itemize}
    \item $K$: Chiều dài ràng buộc của hệ thống.
    \item $x^k$: Giá trị bit thứ k trong thanh ghi dịch.
    \item $y^k$: Giá trị bit thứ k trong đa thức sinh.
\end{itemize}  

Ta có thể nhận thấy đa thức sinh hoạt động như một bit mask: nếu $y^k$ = 1, giá trị $x^k$ được giữ lại, nếu $y^k$ = 0, giá trị $x^k$ bị loại bỏ. Nhận xét trên cho thấy cấu trúc phần cứng cho chiều dài ràng buộc lớn có thể tái sử dụng cho chiều dài ràng buộc nhỏ. Khi dùng cấu trúc $K$ lớn cho $K'$ nhỏ, chỉ cần đặt $y^k = 0$ với mọi $k > K'$. Như vậy, hệ thống có thể linh hoạt mở rộng mà không cần thay đổi kiến trúc phần cứng cơ bản. 

\section{Kết hợp mã hóa tích chập và giải mã Viterbi}
\label{section:Kết hợp mã hóa tích chập và giải mã Viterbi}

Thiết kế ban đầu của đề tài chỉ tập trung vào triển khai bộ giải mã Viterbi trên FPGA. Tuy nhiên, trong quá trình thực hiện, người thiết kế nhận thấy rằng việc hỗ trợ tất cả các đa thức sinh khả thi với thông số R = 1/3, K = 9 và 1024 dịch chuyển mỗi chu kỳ sẽ đòi hỏi một dung lượng bộ nhớ cực lớn để lưu trữ mọi kết quả có thể. Nhận thức này đã dẫn đến ý tưởng mới: tính toán giá trị đầu ra dựa trên đa thức sinh đầu vào thay vì lưu trữ trước các kết quả.

Để thực hiện phương pháp này, cần tích hợp thêm bộ mã hóa tích chập vào trong bộ giải mã Viterbi. Mặc dù vậy, do thuật toán mã hóa tích chập có độ phức tạp không cao, việc xử lý song song hai luồng dữ liệu (vừa giải mã vừa mã hóa) không phải là thách thức đáng kể. Từ đó, khái niệm về bộ xử lý kết hợp giải mã/mã hóa đã được hình thành.

\section{Tiềm năng cho giải mã Soft Decision}

Một hạn chế đáng kể của bộ giải mã hiện tại là chưa hỗ trợ Soft Decision. Về mặt kiến trúc, việc tích hợp Soft Decision vào thiết kế hiện có tương đối đơn giản, chủ yếu chỉ cần điều chỉnh khối branch\_metric. Tuy nhiên, thách thức chính nằm ở các phép toán đặc thù của Soft Decision, đòi hỏi thực hiện các phép lũy thừa và khai căn - những toán tử mà chỉ có khối DSP trên PYNQ-Z2 mới được tối ưu để xử lý hiệu quả.

Với yêu cầu xử lý 1024 dịch chuyển trong một bước thời gian cùng giới hạn 220 khối DSP trên PYNQ-Z2, giải pháp khả thi duy nhất để triển khai Soft Decision là tăng chu kỳ tính toán trong khối branch\_metric. Tuy nhiên, do luồng dữ liệu được xử lý tuyến tính, bất kỳ sự tắc nghẽn nào ở khối đầu nguồn như branch\_metric sẽ ảnh hưởng nghiêm trọng đến thông lượng tổng thể của hệ thống.

Xuất phát từ những phân tích trên, người thiết kế đã quyết định không triển khai Soft Decision cho hệ thống trong phạm vi đề tài này.

\section{Tối ưu trong Vivado và vấn đề về nghẽn tín hiệu}

Thiết kế hiện tại sử dụng khoảng 80\% tài nguyên PL, một con số tưởng chừng khiêm tốn nhưng thực tế đã đạt ngưỡng gần giới hạn. Nguyên nhân chính xuất phát từ việc vị trí các LUT và FF trên PL là cố định, đòi hỏi phải tối ưu hóa cực kỳ cẩn thận trong việc bố trí tín hiệu kết nối và sắp xếp các khối chức năng.

Trong thực tế triển khai, Vivado thường không thể tổng hợp thành công khi thiết kế vượt quá 85\% tài nguyên do vấn đề tắc nghẽn tín hiệu (congestion). Hơn nữa, việc sử dụng tài nguyên ở mức cao làm tăng đáng kể thời gian tổng hợp và triển khai. Khi mức sử dụng vượt quá 500\%, quá trình tổng hợp LUT, FF và bố trí layout có thể kéo dài hơn 5 giờ, gây ảnh hưởng lớn đến tiến độ phát triển.
\section{Tối ưu khối add\_compare\_select}
\label{section:Tối ưu khối add_compare_select}

Khối add\_compare\_select là thành phần sử dụng nhiều tài nguyên nhất trong hệ thống do phải xử lý hai tác vụ phức tạp: tìm dịch chuyển có path metric nhỏ nhất trong bốn khả năng và xác định nút nhỏ nhất trong 256 nút. Việc tối ưu hóa khối này đặt ra những thách thức đáng kể về mặt kiến trúc. Nguyên nhân chính khiến khối này tiêu tốn nhiều tài nguyên xuất phát từ đặc tính của LUT - vốn là phần tử tổ hợp không có khả năng lưu trữ. Khi các phép toán được nối tiếp mà không có FF trung gian, số lượng LUT cần thiết sẽ tăng theo cấp số mũ. Hơn nữa, bản thân việc triển khai LUT trên FPGA cũng tốn kém tài nguyên do yêu cầu diện tích lớn, khiến chúng trở thành thành phần quý giá cần được sử dụng hợp lý.

Đối với bài toán tìm min\_node trong 256 trạng thái, giải pháp tương đối đơn giản nhờ tính chất tuyến tính của thuật toán. Bằng cách áp dụng phương pháp chia đôi (tree-based comparison), độ trễ tính toán tăng từ 1 lên 8 chu kỳ (tương ứng $\log_{2} 256$) nhưng giúp tiết kiệm đáng kể số lượng LUT sử dụng. Điều đáng mừng là độ trễ này chỉ ảnh hưởng ở giai đoạn cuối của quá trình xử lý, và hoàn toàn chấp nhận được trong hệ thống có 209 chu kỳ cho mỗi khung dữ liệu.

Tuy nhiên, việc tối ưu tính toán path metric lại phức tạp hơn nhiều do yêu cầu đặc thù của thuật toán. Khác với min\_node, path metric đòi hỏi tính toán theo kiểu feed-forward, nghĩa là mỗi kết quả đầu ra phải được xác định trước khi nhận đầu vào tiếp theo. Điều này khiến mọi độ trễ đều có tính chất tích lũy qua các chu kỳ xử lý. Trong bối cảnh tài nguyên hạn chế, người thiết kế buộc phải đưa ra giải pháp cân bằng bằng cách chèn thêm FF trung gian, làm tăng độ trễ từ 1 lên 2 chu kỳ cho mỗi bước tính toán. Với độ sâu dò ngược 64 bước, hệ thống phải chịu thêm 64 chu kỳ trễ tổng cộng. Bên cạnh đó, thông lượng hệ thống còn bị giảm 44\% do bị tăng thêm 64 chu kỳ xử lý cho mỗi khung dữ liệu. Đây là minh chứng rõ ràng cho sự đánh đổi giữa hiệu năng và tài nguyên sử dụng trong thiết kế FPGA.

%\section{Mối tương quan giữa danh sách trạng thái và kiểu mảng trong add\_compare\_select}

\section{Tối ưu khối memory}
\label{section:Tối ưu khối memory}

%\section{Tối ưu endec\_interface và FIFO, tại sao phải dùng Verilog}

\section{Tối ưu điều kiện để giảm utilization}

\section{Thử nghiệm trễ trên Linux}

\section{Tối ưu BD ring trong Scatter Gather AXI DMA}

\section{Heisenbug trong Vitis}

\end{document}