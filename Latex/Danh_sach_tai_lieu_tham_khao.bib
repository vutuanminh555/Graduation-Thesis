@article{sun_fpga_2012,
	title = {{FPGA} {Design} and {Implementation} of a {Convolutional} {Encoder} and a {Viterbi} {Decoder} {Based} on 802.11a for {OFDM}},
	volume = {2012},
	doi = {10.4236/wet.2012.33019},
	abstract = {In this paper, a modified FPGA scheme for the convolutional encoder and Viterbi decoder based on the IEEE 802.11a standards of WLAN is presented in OFDM baseband processing systems. The proposed design supports a generic, robust and configurable Viterbi decoder with constraint length of 7, code rate of 1/2 and decoding depth of 36 symbols. The Viterbi decoder uses full-parallel structure to improve computational speed for the add-compare-select (ACS) modules, adopts optimal data storage mechanism to avoid overflow and employs three distributed RAM blocks to complete cyclic trace-back. It includes the core parts, for example, the state path measure computation, the preservation and transfer of the survivor path and trace-back decoding, etc. Compared to the general Viterbi decoder, this design can effectively decrease the 10\% of chip logic elements, reduce 5\% of power consumption, and increase the encoder and decoder working performance in the hardware implementation. Lastly, relevant simulation results using Verilog HDL language are verified based on a Xinlinx Virtex-II FPGA by ISE 7.1i. It is shown that the Viterbi decoder is capable of decoding (2, 1, 7) convolutional codes accurately with a throughput of 80 Mbps.},
	language = {en},
	author = {Sun, Yan and Ding, Zhizhong},
	month = jul,
	year = {2012},
	note = {Publisher: Scientific Research Publishing},
	file = {Full Text PDF:C\:\\Users\\vutua\\Zotero\\storage\\2DIWKSNC\\Sun and Ding - 2012 - FPGA Design and Implementation of a Convolutional Encoder and a Viterbi Decoder Based on 802.11a for.pdf:application/pdf},
}


@article{li_design_2012,
	title = {Design and {Implementation} of the {Parameterized} {Multi}-{Standard} {High}-{Throughput} {Radix}-4 {Viterbi} {Decoder} on {FPGA}},
	volume = {E95.B},
	doi = {10.1587/transcom.E95.B.1602},
	abstract = {This paper presents a parameterized multi-standard adaptive radix-4 Viterbi decoder with high throughput and low complexity. The proposed Viterbi decoder supports constraint lengths ranging from 3-9, code rates in the range of 1/2-1/3, and arbitrary truncation lengths. We present a novel fabric of Add-Compare-Select Unit (ACSU) and methods of unsigned quantization and efficient normalization that shorten the critical path. The decoder achieves a low bit error ratio in multiple standards, such as GPRS, WiMax, LTE, CDMA, and 3G. The proposed decoder is implemented on Xilinx XC5VLX330 device and the frequency achieved is 181.7MHz. The throughput of the proposed decoder can reach 363Mbps, which is superior to the other current multi-standard Viterbi decoders or radix-4 Viterbi decoders on the FPGA platform.},
	journal = {IEICE Transactions on Communications},
	author = {Li, Rongchun and Dou, Yong and Lei, Yuanwu and Ni, Shice and Guo, Song},
	month = may,
	year = {2012},
	pages = {1602--1611},
	file = {Full Text PDF:C\:\\Users\\vutua\\Zotero\\storage\\N6SRHLQF\\Li et al. - 2012 - Design and Implementation of the Parameterized Multi-Standard High-Throughput Radix-4 Viterbi Decode.pdf:application/pdf},
}



@inproceedings{basavaraj_fpga_2023,
	title = {{FPGA} {Implementation} of {High} {Speed} {Convolutional} {Encoder} and {Viterbi} {Decoder} for {Software} {Defined} {Radio}},
	doi = {10.1109/ICECCT56650.2023.10179840},
	abstract = {Attenuation, interference, noise, and distortion affect any wireless communication system's data transfer, making it more difficult for the receiver to receive precise data. Convolution encoder is used to fix errors at the receiver end. Software defined radio may adjust to different encoding and modulation schemes by changing its configuration. In this work, convolutional encoding with a 1/2 code rate and a 3 length constraint is proposed. The updated Viterbi decoder architecture optimizes the key route, enabling higher speeds. MATLAB is used for simulation to verify the Viterbi design. Verilog HDL for RTL coding and a Xilinx Spartan Series FPGA is used in the implementation. ModelSim and Vivado are used for functional and timings simulations.},
	booktitle = {2023 {Fifth} {International} {Conference} on {Electrical}, {Computer} and {Communication} {Technologies} ({ICECCT})},
	author = {Basavaraj, Hanchinal Punit and M, Pappa},
	month = feb,
	year = {2023},
	keywords = {Computer architecture, Convolutional codes, Decoding, Encoding, Receivers, Register Exchange, SDR, Timing, Trace Back, Trellis, Viterbi, Viterbi algorithm},
	pages = {1--4},
	file = {Snapshot:C\:\\Users\\vutua\\Zotero\\storage\\NQ7PAJSV\\10179840.html:text/html},
}



@inproceedings{mandwale_different_2015,
	title = {Different {Approaches} {For} {Implementation} of {Viterbi} decoder on reconfigurable platform},
	doi = {10.1109/PERVASIVE.2015.7086976},
	abstract = {Generally, the data transmitted over any communication channel is affected due to noise. So, for detecting and correcting the errors due to channel noise, encoding and decoding should be performed at the transmitter and receiver end respectively. The Viterbi algorithm is used in many communication channels for decoding convolutional codes. Using VLSI technology, the system requires low power, less area and high speed constraints while designing. Because of different steps for designing Viterbi Decoder speed of designing is limited. In this paper, different kind of implementation of Viterbi decoder along with their performance has been discussed.},
	booktitle = {2015 {International} {Conference} on {Pervasive} {Computing} ({ICPC})},
	author = {Mandwale, Amruta J. and Mulani, Altaf O.},
	month = jan,
	year = {2015},
	keywords = {Adaptive viterbi decoder, Computer architecture, Decoding, FPGA, GDIL, Measurement, Non-polynomial-approach, Random access memory, Receivers, Register exchange, Transistors, Viterbi algorithm, Viterbi decoder, VLSI},
	pages = {1--4},
}




@misc{noauthor_viterbi_nodate,
	title = {Viterbi {Decoder} - {Decode} convolutionally encoded data using {Viterbi} algorithm - {Simulink}},
	url = {https://www.mathworks.com/help/comm/ref/viterbidecoder.html},
	abstract = {The Viterbi Decoder block decodes convolutionally encoded input symbols to produce binary output symbols by using the Viterbi algorithm.},
	language = {en},
	file = {Snapshot:C\:\\Users\\vutua\\Zotero\\storage\\4ED62E2M\\viterbidecoder.html:text/html},
}



@article{liu_765-gbs_2025,
	title = {76.5-{Gb}/s {Viterbi} {Decoder} for {Convolutional} {Codes} on {GPU}},
	volume = {17},
	issn = {1943-0671},
	doi = {10.1109/LES.2024.3416401},
	abstract = {This letter presents an optimized Viterbi decoder of convolutional codes on graphics processing unit (GPU) for software defined radio (SDR) platforms. Before the forward process, channel messages are interleaved with coalesced global memory access and the interleaved messages are represented with 4 bits to improve shared memory efficiency. Moreover, we optimize on-chip memory allocations of the forward process to accelerate instruction execution. Excluding the data transfer latency between host and device, the proposed Viterbi decoder achieves 22.2 and 76.5-Gb/s throughput on Tesla V100 and RTX4090, respectively. Compared with related works, the throughput speedups achieved by the proposed decoder are from 2.06{\textbackslash}times to 2.93{\textbackslash}times .},
	number = {1},
	journal = {IEEE Embedded Systems Letters},
	author = {Liu, Zhanxian and Liu, Chufan and Zhang, Haijun and Zhao, Ling},
	month = feb,
	year = {2025},
	keywords = {Convolutional code, Decoding, graphics processing unit (GPU), Graphics processing units, Memory management, Message systems, parallel decoding, Quantization (signal), software defined radio (SDR), Throughput, Viterbi, Viterbi algorithm},
	pages = {22--25},
}



@misc{noauthor_tms320c6416_nodate,
	title = {{TMS320C6416} data sheet, product information and support {\textbar} {TI}.com},
	url = {https://www.ti.com/product/TMS320C6416},
	file = {TMS320C6416 data sheet, product information and support | TI.com:C\:\\Users\\vutua\\Zotero\\storage\\C39N9AFQ\\TMS320C6416.html:text/html},
}



@inproceedings{mamarde_viterbi_2018,
	title = {Viterbi {Decoder} {Using} {Zynq}-7000 {AP}-{SoC}},
	doi = {10.1109/ICCONS.2018.8663202},
	abstract = {Data transmission over the wireless transmission channel is adversely affected by attenuation, distortion, interference, and noise, that hampers the ability of the receiver to correctly receive the transmitted message signal. Thus error detection and correction methods are implemented to mitigate these effects. Convolution encoder is one such channel encoding technique used at transmitter end for deep space and wireless communication whereas at receiver end the Viterbi decoder decodes the encoded data. Viterbi algorithm is based on principles of maximum likelihood where the optimal trellis path is identified that is followed at the encoder using cumulative hamming distance. This paper presents an SoC based Hardware-Software codesign approach of implementing the Viterbi Decoder along with the entire communication system comperising of random binary pattern generator, convolution encoder, QPSK modulator, QPSK demodulator and quantizer built on a Zynq-7000 All Programmable SoC chip. The blocks are designed using Verilog HDL (Hardware Description Language) using the tools Vivado IDE (Integrated Development Environment) 2017.4 by Xilinx and HDL coder toolbox of MATLAB 2018 a by MathWorks. Simulink model of the communication chain is implemented to simulate the design considering the effect of AWGN (Additive White Gaussian Noise) through the channel and then the partial design is translated to be implemented on a Zynq-7000 AP SoC. This design can find potential applications in Satellite communication, SDR (Software Defined Radio).},
	booktitle = {2018 {Second} {International} {Conference} on {Intelligent} {Computing} and {Control} {Systems} ({ICICCS})},
	author = {Mamarde, Raj and Khoje, Suchitra},
	month = jun,
	year = {2018},
	keywords = {Convolution, Convolution Encoder, Decoding, Encoding, Hardware design languages, Mathematical model, Matlab, SDR, Simulink, Software packages, Verilog HDL, Viterbi algorithm, Viterbi Decoder, Vivado, Zynq-7000 AP SoC},
	pages = {941--944},
}



@misc{noauthor_acceleration_nodate,
	title = {Acceleration in the {AWS} {Cloud}},
	url = {https://www.amd.com/en/where-to-buy/accelerators/alveo/cloud-solutions/aws.html},
	abstract = {AMD FPGAs are available in the Amazon Elastic Compute Cloud (Amazon EC2) F1 instances. F1 instances are designed to accelerate data center workloads including machine learning inference, data analytics, video processing, and genomics.},
	language = {en},
	journal = {AMD},
	file = {Snapshot:C\:\\Users\\vutua\\Zotero\\storage\\3MWZVP6R\\aws.html:text/html},
}



@article{black_140-mbs_1992,
	title = {A 140-{Mb}/s, 32-state, radix-4 {Viterbi} decoder},
	volume = {27},
	issn = {1558-173X},
	doi = {10.1109/4.173118},
	abstract = {A 140-Mb/s, 32-state, radix-4, R=1/2, eight-level soft-decision Viterbi decoder has been designed and fabricated using 1.2- mu m double-metal CMOS. The architecture of the add-compare-select (ACS) array is based on a restructuring of the conventional radix-2 trellis into a radix-4 trellis. Radix-4 units, consisting of four 4-way ACS units, process two stages of the constituent radix-2 trellis per iteration. A four-way ACS circuit achieves an iteration delay 17\% longer than comparable two-way ACS circuits, resulting in a factor of 1.7 increase in throughput. A ring-based ACS placement and state metric routing topology achieves an area efficiency comparable to radix-2 designs. In a process referred to as pretrace-back, one stage of lookahead is applied to the trace-back recursion, combining two radix-4 trace-back iterations into a single radix-16 iteration based on 4-b decisions. This allows implementation of trace-back using one compact, single-ported decision memory, organized as a cyclic buffer. A 7.30-mm*8.49-mm chip containing 146000 transistors achieves a radix-4 iteration rate of 70 MHz.{\textless}{\textgreater}},
	number = {12},
	journal = {IEEE Journal of Solid-State Circuits},
	author = {Black, P.J. and Meng, T.H.},
	month = dec,
	year = {1992},
	keywords = {Algorithm design and analysis, Circuit topology, Convolutional codes, Delay, Demodulation, Error correction codes, Iterative decoding, Routing, Throughput, Viterbi algorithm},
	pages = {1877--1885},
}



@misc{a_viterbi_error_nodate,
	title = {Error bounds for convolutional codes and an asymptotically optimum decoding algorithm},
	abstract = {The probability of error in decoding an optimal convolutional code transmitted over a memoryless channel is bounded from above and below as a function of the constraint length of the code. For all but pathological channels the bounds are asymptotically (exponentially) tight for rates above{\textless}tex xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"{\textgreater}R\_\{0\}{\textless}/tex{\textgreater}, the computational cutoff rate of sequential decoding. As a function of constraint length the performance of optimal convolutional codes is shown to be superior to that of block codes of the same length, the relative improvement increasing with rate. The upper bound is obtained for a specific probabilistic nonsequential decoding algorithm which is shown to be asymptotically optimum for rates above{\textless}tex xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"{\textgreater}R\_\{0\}{\textless}/tex{\textgreater}and whose performance bears certain similarities to that of sequential decoding algorithms.},
	author = {A. Viterbi},
	file = {Snapshot:C\:\\Users\\vutua\\Zotero\\storage\\VYQMXPLU\\1054010.html:text/html},
}




@incollection{noauthor_fundamentals_2015,
	title = {Fundamentals of {Convolutional} {Coding}},
	isbn = {978-1-119-09879-9},
	abstract = {The prelims comprise: Half Title Title Copyright Dedication Contents Preface Acknowledgement},
	language = {en},
	booktitle = {Fundamentals of {Convolutional} {Coding}},
	publisher = {John Wiley \& Sons, Ltd},
	year = {2015},
	doi = {10.1002/9781119098799.fmatter},
	pages = {i--xv},
	file = {Full Text PDF:C\:\\Users\\vutua\\Zotero\\storage\\G2NCUMVE\\2015 - Fundamentals of Convolutional Coding.pdf:application/pdf;Snapshot:C\:\\Users\\vutua\\Zotero\\storage\\PXIRAJVI\\9781119098799.html:text/html},
}


@misc{noauthor_amd_nodate,
	title = {{AMD} {Zynq}™ 7000 {SoCs}},
	url = {https://www.amd.com/en/products/adaptive-socs-and-fpgas/soc/zynq-7000.html},
	abstract = {AMD Zynq™ 7000 SoC devices integrate the software programmability of an Arm-based processor with the hardware programmability of an FPGA, enabling key analytics and hardware acceleration while integrating CPU, DSP, ASSP, and mixed signal functionality on a single device.},
	language = {en},
	journal = {AMD},
}


@misc{noauthor_zynq-7000_2019,
	title = {Zynq®-7000 {SoC} {First} {Generation} {Architecture}},
	url = {https://www.mouser.in/xilinx-zynq-7000-socs},
	abstract = {AMD / Xilinx Zynq®-7000 SoC First Generation Architecture allows a flexible platform to launch new solutions while providing traditional ASIC and SoC users a fully programmable alternative.},
	language = {en-in},
	month = may,
	year = {2019},
	file = {Snapshot:C\:\\Users\\vutua\\Zotero\\storage\\VGJEI49Q\\xilinx-zynq-7000-socs.html:text/html},
}


@misc{noauthor_amba_nodate,
	title = {{AMBA}® {AXI4} {Interface} {Protocol}},
	url = {https://shorturl.at/qNCns},
	abstract = {AMBA® AXI4 (Advanced eXtensible Interface 4) is the fourth generation of the AMBA interface specification from Arm®.},
	language = {en},
	journal = {AMD},
}


@misc{noauthor_introduction_nodate,
	title = {Introduction • {AXI} {DMA} {LogiCORE} {IP} {Product} {Guide} ({PG021}) • {Reader} • {AMD} {Technical} {Information} {Portal}},
	url = {https://docs.amd.com/r/en-US/pg021_axi_dma/Introduction},
	file = {Introduction • AXI DMA LogiCORE IP Product Guide (PG021) • Reader • AMD Technical Information Portal:C\:\\Users\\vutua\\Zotero\\storage\\UFBQDBAG\\Introduction.html:text/html},
}


@misc{russell_what_2022,
	title = {What is a {Block} {RAM} in an {FPGA}? {For} {Beginners}.},
	shorttitle = {What is a {Block} {RAM} in an {FPGA}?},
	url = {https://nandland.com/lesson-15-what-is-a-block-ram-bram/},
	abstract = {What is a Block RAM in an FPGA? Learn how to create BRAMs in VHDL and Verilog, for use in Dual Port RAMs, FIFOs, and more! Tutorial for beginners.},
	language = {en-US},
	journal = {Nandland},
	author = {Russell},
	month = jun,
	year = {2022},
}


@misc{noauthor_integrated_nodate,
	title = {Integrated {Logic} {Analyzer} ({ILA})},
	url ={https://shorturl.at/Giu1Q},
	abstract = {The LogiCORE™ IP Integrated Logic Analyzer (ILA) core is a customizable logic analyzer core that can be used to monitor any internal signal of your design.},
	language = {en},
	journal = {AMD},
}


@misc{noauthor_lwip_nodate,
	title = {{lwIP} - {A} {Lightweight} {TCP}/{IP} stack - {Summary} [{Savannah}]},
	url = {https://savannah.nongnu.org/projects/lwip/},
}


@misc{noauthor_what_nodate,
	title = {What is {TCP} ({Transmission} {Control} {Protocol})?},
	url ={https://shorturl.at/g3RTU},
	abstract = {Your All-in-One Learning Portal: GeeksforGeeks is a comprehensive educational platform that empowers learners across domains-spanning computer science and programming, school education, upskilling, commerce, software tools, competitive exams, and more.},
	language = {en-US},
	journal = {GeeksforGeeks},
	note = {Section: Computer Subject},
}


@misc{mesh_network,
	title = {What is {Mesh} {Network}?},
	url = {https://www.geeksforgeeks.org/computer-networks/what-is-mesh-network/},
	abstract = {Your All-in-One Learning Portal: GeeksforGeeks is a comprehensive educational platform that empowers learners across domains-spanning computer science and programming, school education, upskilling, commerce, software tools, competitive exams, and more.},
	language = {en-US},
	journal = {GeeksforGeeks},
	note = {Section: Computer Networks},
}


@misc{noauthor_tailscale_nodate,
	title = {Tailscale: {How} it works},
	shorttitle = {Tailscale},
	url = {https://tailscale.com/blog/how-tailscale-works},
	abstract = {Understand the entire Tailscale system, how it works, how we built it, and its benefits compared to legacy VPNs. Use this article as a guide to quickly build your own Tailscale replacement.},
}


@article{heller_viterbi_1971,
	title = {Viterbi {Decoding} for {Satellite} and {Space} {Communication}},
	volume = {19},
	issn = {2162-2175},
	doi = {10.1109/TCOM.1971.1090711},
	abstract = {Convolutional coding and Viterbi decoding, along with binary phase-shift keyed modulation, is presented as an efficient system for reliable communication on power limited satellite and space channels. Performance results, obtained theoretically and through computer simulation, are given for optimum short constraint length codes for a range of code constraint lengths and code rates. System efficiency is compared for hard receiver quantization and 4 and 8 level soft quantization. The effects on performance of varying of certain parameters relevant to decoder complexity and cost is examined. Quantitative performance degradation due to imperfect carrier phase coherence is evaluated and compared to that of an uncoded system. As an example of decoder performance versus complexity, a recently implemented 2-Mbit/s constraint length 7 Viterbi decoder is discussed. Finally a comparison is made between Viterbi and sequential decoding in terms of suitability to various system requirements.},
	number = {5},
	journal = {IEEE Transactions on Communication Technology},
	author = {Heller, J. and Jacobs, I.},
	month = oct,
	year = {1971},
	keywords = {Artificial satellites, Computer simulation, Constraint theory, Convolutional codes, Decoding, Modulation coding, Phase modulation, Power system reliability, Quantization, Viterbi algorithm},
	pages = {835--848},
	file = {Snapshot:C\:\\Users\\vutua\\Zotero\\storage\\9WLGQFWE\\1090711.html:text/html},
}


@inproceedings{feygin_survivor_1991,
	title = {Survivor sequence memory management in {Viterbi} decoders},
	doi = {10.1109/ISCAS.1991.176168},
	abstract = {This work extends previous trace-back approaches. A new
one-pointer trace-back algorithm for survivor sequence memory management that is particularly well-suited to a VLSI implementation is described. Memory size, latency and implementational complexity of the survivor sequence management are analyzed for both uniprocessor and
multiprocessor realizations of Viterbi decoders},
	author = {Feygin, Gennady and Gulak, P.G.},
	month = jul,
	year = {1991},
	pages = {2967--2970 vol.5},
	file = {Full Text PDF:C\:\\Users\\vutua\\Zotero\\storage\\JWSRWM53\\Feygin and Gulak - 1991 - Survivor sequence memory management in Viterbi decoders.pdf:application/pdf},
}


@misc{noauthor_aup_nodate,
	title = {{AUP} {PYNQ}-{Z2}},
	url = {https://www.amd.com/en/corporate/university-program/aup-boards/pynq-z2.html},
	abstract = {PYNQ is an open-source project from AMD that makes it easier to use AMD platforms. Using the Python language and libraries, designers can exploit the benefits of programmable logic and micro-processors to build more capable and exciting electronic systems.},
	language = {en},
	journal = {AMD},
}


@article{forney_convolutional_1970,
	title = {Convolutional codes {I}: {Algebraic} structure},
	volume = {16},
	issn = {1557-9654},
	shorttitle = {Convolutional codes {I}},
	doi = {10.1109/TIT.1970.1054541},
	abstract = {A convolutional encoder is defined as any constant linear sequential circuit. The associated code is the set of all output sequences resulting from any set of input sequences beginning at any time. Encoders are called equivalent if they generate the same code. The invariant factor theorem is used to determine when a convolutional encoder has a feedback-free inverse, and the minimum delay of any inverse. All encoders are shown to be equivalent to minimal encoders, which are feedback-free encoders with feedback-free delay-free inverses, and which can be realized in the conventional manner with as few memory elements as any equivalent encoder, Minimal encoders are shown to be immune to catastrophic error propagation and, in fact, to lead in a certain sense to the shortest decoded error sequences possible per error event. In two appendices, we introduce dual codes and syndromes, and show that a minimal encoder for a dual code has exactly the complexity of the original encoder; we show that systematic encoders with feedback form a canonical class, and compare this class to the minimal class.},
	number = {6},
	journal = {IEEE Transactions on Information Theory},
	author = {Forney, G.},
	month = nov,
	year = {1970},
	pages = {720--738},
	file = {Snapshot:C\:\\Users\\vutua\\Zotero\\storage\\8DMDFKPJ\\1054541.html:text/html},
}


@article{masseyy_inverses_1968,
	title = {Inverses of {Linear} {Sequential} {Circuits}},
	volume = {C-17},
	issn = {1557-9956},
	doi = {10.1109/TC.1968.229392},
	abstract = {Abstract—This paper states the necessary and sufficient conditions for the existence of a feedforward inverse for a feedforward linear sequential circuit and gives an implicit procedure for constructing such inverses. It then goes on to give the necessary and sufficient conditions for the existence of general inverses with finite delay and gives procedures for constructing a class of such inverses. The discussion considers both the transfer function matrix description and the structural matrix description of the linear sequential circuit, together with the complementary nature of the results obtained from these two viewpoints. Finally, a large part of the work is motivated by results and techniques which have been applied in the study of continuous-time linear dynamical systems and thus serves to point out the advantages which may accrue through simultaneous study of both continuous-time systems and linear sequential circuits.},
	number = {4},
	journal = {IEEE Transactions on Computers},
	author = {MasseyY, J.L. and Sain, M.K.},
	month = apr,
	year = {1968},
	keywords = {Index terms—Convolution codes, feedforward sequential circuits, information lossless, inverses, linear sequential circuits.},
	pages = {330--337},
	file = {Snapshot:C\:\\Users\\vutua\\Zotero\\storage\\YNK7P4JG\\1687344.html:text/html},
}


@misc{admin_uvm_nodate,
	title = {{UVM} {Tutorial}},
	url = {https://shorturl.at/5mxJY},
	abstract = {UVM is a framework API used to build modular and scalable verification testbenches. Click here to learn UVM concepts ASAP using real simple examples right now !},
	language = {en-GB},
	journal = {ChipVerify},
	author = {Admin},
	file = {Snapshot:C\:\\Users\\vutua\\Zotero\\storage\\NP5R8L94\\uvm.html:text/html},
}



@article{gallery_hardwaresoftware_2003,
	title = {Hardware/{Software} {Codesign}},
	copyright = {Creative Commons Attribution-Noncommercial-Share Alike 3.0 License},
	doi = {10.21427/D7NB29},
	language = {en},
	author = {Gallery, Richard},
	year = {2003},
	note = {Publisher: Dublin Institute of Technology},
	file = {PDF:C\:\\Users\\vutua\\Zotero\\storage\\2NKSTZP9\\Gallery - 2003 - HardwareSoftware Codesign.pdf:application/pdf},
}
